\input{../templates/slides_template}	% nothing to do here
% TODO change "course_info" to the name of your actual …_info(.tex)
\input{course_info} % TODO modify this if you have not already done so
\usepackage[utf8]{inputenc}

% meta-information
\newcommand{\topic}{
	% TODO fill in the actual topic
	Builtin Datenstrukturen
}

% nothing to do here
\title{\topic}
\supertitle{\course}
\date{\today}

% the actual document
\begin{document}

\maketitle

\begin{frame}
	\tableofcontents
\end{frame}

\section{exceptions}
\begin{frame}{Exception Handling}
\begin{itemize}
	\item Alle Exceptions erben von \texttt{Exception}
	\item Catching mit try/except
	\item \texttt{finally} um Code auszuführen, der \textit{unbedingt} laufen muss, egal ob eine Exception vorliegt oder nicht
\end{itemize}
\end{frame}
\begin{frame}{Exception Handling}
\lstinputlisting{resources/03_builtins/exceptions.py}
\end{frame}

\section{booleans}
\begin{frame}{Boolsche Werte}
\begin{itemize}
	\item \textit{type} ist \texttt{bool}
	\item Mögliche Werte: \texttt{True} oder \texttt{False}
	\item Operationen sind \textit{und}, \textit{oder}, \textit{nicht} \texttt{and, or, not}
\end{itemize}
\end{frame}

\section{list}
\begin{frame}{list}

\begin{itemize}
	\item enthält variable Anzahl von Objekten
	\item eine Liste kann beliebig viele verschiedene Datentypen enthalten (z.B. \texttt{bool} und \texttt{list})
	\item Auch Listen können in Listen gespeichert werden!
	\item Listenobjekte haben eine feste Reihenfolge (\textit{first in, last out})
	\item optimiert für einseitige Benutzung wie z.B. Queue (\texttt{append} und \texttt{pop})
\end{itemize}
\end{frame}
\begin{frame}{list}
	\lstinputlisting{resources/03_builtins/list.py}
\end{frame}

\section{tuple}
\begin{frame}{tuple}
\begin{itemize}
	\item Gruppiert Daten
	\item kann nicht mehr verändert werden, sobald es erstellt wurde
	\item Funktionen mit mehreren Rückgabewerten geben ein Tupel zurück
\end{itemize}
\end{frame}
\begin{frame}{tuple}
	\lstinputlisting{resources/03_builtins/tuple.py}
\end{frame}


\section{dict}
\begin{frame}{dict}
\begin{itemize}
	\item einfache HashMap
	\item ungeordnet
	\item jeder hashbare Typ kann ein Key sein
	\item jedem Key ist dann ein Value zugeordnet
\end{itemize}
\end{frame}
\begin{frame}{dict}
\lstinputlisting{resources/03_builtins/dict.py}
\end{frame}

\section{set/frozenset}
\begin{frame}{set/frozenset}
\begin{itemize}
	\item kann nur hashbare Einträge enthalten
	\item \texttt{set} selbst ist nicht hashbar
	\item \texttt{frozensets} sind hashbar, jedoch nicht mehr veränderbar
	\item enhält jedes Element nur einmal
	\item schnellere Überprüfung mit \texttt{in} (prüft, ob Element enthalten ist)
	% TODO
	\item Mögliche Operationen: \texttt{superset()}, \texttt{subset()}, \texttt{isdisjoint()}, \texttt{difference()}, \texttt{<, >, disdisjoint(), -}
	\item ungeordnet
	\item (frozen)sets können frozensets enthalten
\end{itemize}
\end{frame}
\begin{frame}{set/frozenset}
	\lstinputlisting{resources/03_builtins/set.py}
\end{frame}

\section{iteraton}
\begin{frame}{Iteration}
\begin{itemize}
	\item nur foreach
	\item für Iterationen über Integer gibt es \texttt{range([start], stop, step=1)}
	\item um Iteratoren zu kombinieren kann man \texttt{zip(iterator_1, iterator_2, ..., iterator_n)} verwenden
	\item alles mit einer \texttt{__iter__} Methode ist iterierbar
	% TODO: stateful Iterator erklären oder entfernen
	\item \texttt{iter(iterable)} konstruiert einen \textit{stateful iterator}
\end{itemize}
\end{frame}
\begin{frame}{Iteration}
	% TODO am Ende noch mal gucken, ob die Zeilen passen!
	\lstinputlisting[lastline=28]{resources/03_builtins/iterate.py}
\end{frame}
\begin{frame}{Iteration}
	\lstinputlisting[firstline=30]{resources/03_builtins/iterate.py}
\end{frame}

\section{unpacking}
\begin{frame}{Unpacking}
\begin{itemize}
	\item einfaches Auflösen von Listen und Tupeln in einzelne Variablen
	\item nützlich in \textt{for} Schleifen
\end{itemize}
\end{frame}
\begin{frame}{unpacking}
	\lstinputlisting{resources/03_builtins/unpacking.py}
\end{frame}

\section{Contenxt Manager}
\begin{frame}{Context Manager}
\begin{itemize}
	\item Aufruf mit \texttt{with}
	\item kann jedes Objekt sein, welches eine \texttt{__enter__} und \texttt{__exit__} Methode hat
	\item praktisch beim \textit{File Handling}
\end{itemize}
\end{frame}
\begin{frame}{Context Manager}
	\lstinputlisting{resources/03_builtins/cm.py}
\end{frame}

\section{File Handling}
\begin{frame}{File Handling}
\begin{itemize}
	\item Dateien können mit \texttt{open(filename, mode="r")} geöffnet werden
	\item \textit{File Handler} sind Iteratoren über die Zeilen einer Datei
	\item \textbf{Wichtig:} File Handler müssen auch wieder geschlossen werden
	\item \texttt{r} steht für Lesezugriff,  \texttt{w} für Schreibzugriff
\end{itemize}[.5cm]
\textbf{Beachte:} Wird eine Datei mit Schreibzugriff geöffnet, wird sie geleert! Also wichtige Inhalte vorher auslesen.
\end{frame}
\begin{frame}{File Handling}
	\lstinputlisting{resources/03_builtins/file.py}
\end{frame}

% nothing to do from here on
\end{document}
