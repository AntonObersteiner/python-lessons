\input{../templates/slides_template}	% nothing to do here
% TODO change "course_info" to the name of your actual â€¦_info(.tex)
\input{../templates/course_info} % TODO modify this if you have not already done so
\usepackage[utf8]{inputenc}

% meta-information
\newcommand{\topic}{
	% TODO fill in the actual topic
	Builtin Datenstrukturen
}

% nothing to do here
\title{\topic}
\supertitle{\course}
\date{\today}

% the actual document
\begin{document}

\maketitle

\begin{frame}
	\tableofcontents
\end{frame}

\section{exceptions}
\begin{frame}{Exception Handling}
\begin{itemize}
	\item Alle Exceptions erben von \texttt{Exception}
	\item Catching mit try/except
	\item \texttt{finally} um Code auszuf\"uhren, der \textit{unbedingt} laufen muss, egal ob eine Exception vorliegt oder nicht
\end{itemize}
\end{frame}
\begin{frame}{Exception Handling}
\lstinputlisting{resources/03_builtins/exceptions.py}
\end{frame}

\section{booleans}
\begin{frame}{Boolsche Werte}
\begin{itemize}
	\item \textit{type} ist \texttt{bool}
	\item M\"ogliche Werte: \texttt{True} oder \texttt{False}
	\item Operationen sind \textit{und}, \textit{oder}, \textit{nicht} (\texttt{and, or, not})
\end{itemize}
\end{frame}

\section{list}
\begin{frame}{list}

\begin{itemize}
	\item enth\"alt variable Anzahl von Objekten
	\item eine Liste kann beliebig viele verschiedene Datentypen enthalten (z.B. \texttt{bool} und \texttt{list})
	\item Auch Listen k\"onnen in Listen gespeichert werden!
	\item Listenobjekte haben eine feste Reihenfolge (\textit{first in, last out})
	\item optimiert f\"ur einseitige Benutzung wie z.B. Queue (\texttt{append} und \texttt{pop})
\end{itemize}
\end{frame}
\begin{frame}{list}
	\lstinputlisting{resources/03_builtins/list.py}
\end{frame}

\section{tuple}
\begin{frame}{tuple}
\begin{itemize}
	\item Gruppiert Daten
	\item kann nicht mehr ver\"andert werden, sobald es erstellt wurde
	\item Funktionen mit mehreren R\"uckgabewerten geben ein Tupel zur\"uck
\end{itemize}
\end{frame}
\begin{frame}{tuple}
	\lstinputlisting{resources/03_builtins/tuple.py}
\end{frame}


\section{dict}
\begin{frame}{dict}
\begin{itemize}
	\item einfache HashMap
	\item ungeordnet
	\item jeder hashbare Typ kann ein Key sein
	\item jedem Key ist dann ein Value zugeordnet
\end{itemize}
\end{frame}
\begin{frame}{dict}
\lstinputlisting{resources/03_builtins/dict.py}
\end{frame}

\section{set/frozenset}
\begin{frame}{set/frozenset}
\begin{itemize}
	\item kann nur hashbare Eintr\"age enthalten
	\item \texttt{set} selbst ist nicht hashbar
	\item \texttt{frozensets} sind hashbar, jedoch nicht mehr ver\"anderbar
	\item enth\"alt jedes Element nur einmal
	\item schnellere \"Uberpr\"ufung mit \texttt{in} (pr\"uft, ob Element enthalten ist)
	\item M\"ogliche Operationen: \texttt{superset()}, \texttt{subset()}, \texttt{isdisjoint()}, \texttt{difference()}, \texttt{<, >, disdisjoint(), -}
	\item ungeordnet
	\item (frozen)sets k\"onnen frozensets enthalten
\end{itemize}
\end{frame}
\begin{frame}{set/frozenset}
	\lstinputlisting{resources/03_builtins/set.py}
\end{frame}

\section{iteraton}
\begin{frame}{Iteration}
\begin{itemize}
	\item nur foreach
	\item f\"ur Iterationen \"uber Integer gibt es \texttt{range([start], stop, step=1)}
	\item um Iteratoren zu kombinieren kann man \texttt{zip(iterator\_1, iterator\_2, ..., iterator\_n)} verwenden
	\item alles mit einer \texttt{\_\_iter\_\_} Methode ist iterierbar
	% TODO: stateful Iterator erklaeren oder entfernen
	\item \texttt{iter(iterable)} konstruiert einen \textit{stateful iterator}
\end{itemize}
\end{frame}
\begin{frame}{Iteration}
	% TODO am Ende noch mal gucken, ob die Zeilen passen!
	\lstinputlisting[lastline=28]{resources/03_builtins/iterate.py}
\end{frame}
\begin{frame}{Iteration}
	\lstinputlisting[firstline=30]{resources/03_builtins/iterate.py}
\end{frame}

\section{unpacking}
\begin{frame}{Unpacking}
\begin{itemize}
	\item einfaches Aufl\"osen von Listen und Tupeln in einzelne Variablen
	\item n\"utzlich in \texttt{for}-Schleifen
\end{itemize}
\end{frame}
\begin{frame}{unpacking}
	\lstinputlisting{resources/03_builtins/unpacking.py}
\end{frame}

\section{File Handling}
\begin{frame}{File Handling}
\begin{itemize}
	\item Dateien k\"onnen mit \texttt{open(filename, mode="r")} ge\"offnet werden
	\item \textit{File Handler} sind Iteratoren \"uber die Zeilen einer Datei
	\item \textbf{Wichtig:} File Handler m\"ussen auch wieder geschlossen werden
	\item \texttt{r} steht f\"ur Lesezugriff,  \texttt{w} f\"ur Schreibzugriff
\end{itemize}
\textbf{Beachte:} Wird eine Datei mit Schreibzugriff ge\"offnet, wird sie geleert! Also wichtige Inhalte vorher auslesen.
\end{frame}
\begin{frame}{File Handling}
	\lstinputlisting{resources/03_builtins/file.py}
\end{frame}

\section{Context Manager}
\begin{frame}{Context Manager}
\begin{itemize}
	\item Aufruf mit \texttt{with}
	\item kann jedes Objekt sein, welches eine \texttt{\_\_enter\_\_} und \texttt{\_\_exit\_\_} Methode hat
	\item praktisch beim \textit{File Handling}
\end{itemize}
\end{frame}
\begin{frame}{Context Manager}
	\lstinputlisting{resources/03_builtins/cm.py}
\end{frame}

% nothing to do from here on
\end{document}
