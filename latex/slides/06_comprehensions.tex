
%%	Getting started:
%%	1) Copy this file and name the copy it like the topic it covers
%%	2) In the following make sure to modify the copy, NOT THE ORIGINAL
%%	3) Look for the points marked with "TODO" and complete them
%%	4) compile this file

\input{../templates/slides_template}	% nothing to do here
% TODO change "course_info" to the name of your actual …_info(.tex)
\input{course_info} % TODO modify this if you have not already done so

% meta-information
\newcommand{\topic}{
	% TODO fill in the actual topic
	Comprehensions
}

% nothing to do here
\title{\topic}
\supertitle{\course}
\date{\today}

% the actual document
\begin{document}

\maketitle

\begin{frame}
	\tableofcontents
\end{frame}


%% Für einzelne Zeilen Code \codeline{} vewenden (ist mit Markup) für einzelne Worte \texttt{} verwenden (auch in Tabellen!)

\section{Basics}
\begin{frame}{Basics}
  Comprehensions sind eine bequeme Art und Weise, um Funktoren (Datenstrukturen, die andere Datenstrukturen beinhalten) mit kleinen Expressions zu erstellen und zu füllen und sind in allen modernen Sprachen vorhanden.
\end{frame}



\section{List Comprehension}
\begin{frame}{List Comprehension}
  Grundlegender Syntax: \codeline{[ EXPRESSION for LAUFVARIABLE in ITERABLE (if FILTER) ]}\\
  \begin{description}
    \item[EXPRESSION] Ist ein beliebiger Ausdruck (man stelle sich ein implizites \texttt{return} vor). Wie ein Wert, eine Variable, eine Gleichung, etc ... \\
    	\texttt{EXPRESSION} wird am Ende in der Liste abgelegt.
    \item[LAUFVARIABLE] Eine beliebige Variable, die in \textit{EXPRESSION} und \textit{FILTER} zur verfügung steht
    \item[ITERABLE] Ist häufig etwas wie \texttt{range()} oder eine andere Liste.
    \item[FILTER] Eine optionale boolean expression, womit Einträge gefiltert werden (falls \texttt{False}). N\"utzlich, wenn z.B. nur gerade Zahlen \"ubernommen werden sollen, usw...
  \end{description}

\end{frame}

\begin{frame}{List Comprehension - Beispiel}
	\lstinputlisting{resources/06_comprehensions/lists.py}
\end{frame}



\section{Dict Comprehension}
\begin{frame}{Dict Comprehension}
  Grundlegender Syntax: \codeline{\{ KEY : VALUE for LAUFVARIABLE in ITERABLE (if FILTER) \}}\\[.75cm]
  Fast der gleiche Syntax, nur dieses Mal mit 2 Expressions: \textit{KEY} und \textit{VALUE}. Ansonsten gelten die gleichen Regeln.
\end{frame}

\begin{frame}{Dict Comprehension - Beispiel}
	\lstinputlisting{resources/06_comprehensions/dicts.py}
\end{frame}



\section{Generators}
\begin{frame}{Generators}
	\begin{description}
		\item[Generator] Ein Objekt, \"uber das iteriert werden kann. Wenn ein Element daraus verwendet wurde, ist es nicht mehr in dem Generatorobjekt enthalten.\\[.5cm]
	\end{description}
	
	Die grundlegende Syntax ist gleich der einer \textit{List Comprehension}.
	Da sich \codeline{list} und \codeline{dict} auch aus Iterables bauen lassen gilt prinzipiell:\\[.25cm]

		\codeline{list(EXPRESSION for VARIABLE in ITERABLE) == [EXPRESSION for VARIABLE in ITERABLE]}\\[.25cm]
		und\\[.25cm]
		\codeline{dict((KEY, VALUE) for VARIABLE in ITERABLE) == \{KEY:VALUE for VARIABLE in ITERABLE\}}\\[.25cm]

	\textbf{Aber:} Generators verhalten sich anders als Lists oder Dicts!

\end{frame}


%\section{Misc}
%\begin{frame}{Misc}
%  Mit \texttt{tuple()} und der generator expression lassen sich theoretisch auch tuple comprehensions bauen, ist aber konzeptionell eher Unsinn.
%\end{frame}


% nothing to do from here on
\end{document}
