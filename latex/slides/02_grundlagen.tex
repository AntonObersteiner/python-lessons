% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
\title{Grundlagen}
\date{\today}
\setlength{\columnsep}{.4cm}

\begin{document}

\maketitle

\begin{frame}{Gliederung}
	\begin{multicols}{2}
		\setbeamertemplate{section in toc}[sections numbered]
		\tableofcontents
	\end{multicols}
\end{frame}


\section{Wiederholung}
\subsection{Gemeinsamkeiten und Unterschiede}
\begin{frame}{Unterschiede und Gemeinsamkeiten}
    \begin{multicols}{2}
        \lstinputlisting{resources/02_grundlagen/say_hi_print.py}
        \onslide<2->\lstinputlisting{resources/02_grundlagen/say_hi_return.py}
    \end{multicols}
    \begin{tabular}{r|l|l}
        \onslide<2->Eigenschaft & \texttt{print}-Version & \texttt{return}-Version \\ \hline
        \onslide<3->{Strings?    & \texttt{f"\{var\}"} Format-String & {\textcolor{red}{\texttt{+}}}-Operator } \\
        \onslide<4->{Argumente   & \texttt{greeting} hat Standard- & Beide Argumente sind \\
                    & Argument \texttt{"Hi"} & notwendig } \\
        \onslide<5->{Fehler?    & keine & Missing Argument } \\
        \onslide<6->{Effekt      & Funktion gibt aus & Funktion gibt zurück \\
                    &   & $\to$ in Datei geschrieben } \\
        \onslide<7->{Bedingung   & Nur wenn Skript & wird immer gemacht \\
                    & direkt ausgeführt wird & \\
                    & (\texttt{\_\_name\_\_ == "\_\_main\_\_"}) & } \\
    \end{tabular}
\end{frame}
\begin{frame}{Boilerplate}
	\lstinputlisting{resources/02_grundlagen/boilerplate.py}
	Ausführbare Python-Datei vs. Bibliothek $\to$ \alert{\tt main}-Funktion.\\
	Boilerplate unterscheidet: Main oder Bibliothek? \\
\end{frame}
\subsection{Fehler}
\begin{frame}{Auftreten von Fehlern}
    \begin{itemize}
        \item Wann bemerkt man Fehler?
        \item<2-> Syntax-Fehler am Anfang
        \item<3-> Alle anderen bei der Ausführung!
        \item<4-> Deswegen komplizierten Code Testen! (später)
    \end{itemize}
\end{frame}

\section{Scopes}
\subsection{Das Scoping Problem}
\begin{frame}{Das Problem mit dem Scope}
	\lstinputlisting{resources/02_grundlagen/scope.py}
    \onslide<2->{
	\textbf{\alert{Das Problem:}} \\[.25cm]
	Variablen sind zwar nach innen sichtbar, werden aber innerhalb der Funktion neu angelegt.}
\end{frame}

\begin{frame}{\tt global}
	\lstinputlisting{resources/02_grundlagen/scope_fix.py}
    Das ist meist Gaffa, keine dauerhafte Lösung! \\
    Variablen als Argumente übergeben und sinnvoll strukturieren \\
    $\Rightarrow$ Objekte
\end{frame}

\section{Objekte}
\subsection{Klassen, Objekte und Attribute}
\begin{frame}{Klassen und Attribute}
	\begin{itemize}
		\item<1-> Klassen sind wie Schablonen
        \item<2-> Objekte sind konkrete Instanzen
	\end{itemize}
    \onslide<3->\lstinputlisting{resources/02_grundlagen/class.py}
    \onslide<3->{auf Deutsch: selbst festgelegt}
    %%don't do -> not shown
	% \begin{itemize}
	% 	\item Man kann Objekten jederzeit neue Attribute hinzufügen (auch \texttt{type}-Objekten)
	% 	\item Ist außerhalb des Initialisierers nicht empfehlenswert
	% \end{itemize}
\end{frame}

\begin{frame}{Attribute}
	Attribute setzen: meist im \textbf{Initialisierer} \alert{\tt \_\_init\_\_}
	\lstinputlisting{resources/02_grundlagen/attributes.py}
    auf Deutsch: selbst festgelegt
\end{frame}

\subsection{Methoden}
\begin{frame}{Methoden}
	\begin{itemize}
		\item Funktionen, die Teil von Klassen/Objekten sind
		\item<2-> erstes Argument \texttt{self} wird übergeben
        \item<3-> \texttt{    def method(obj, arg2): ...}
        \item<3-> \texttt{obj.method(arg2)}
	\end{itemize}
\end{frame}

\subsubsection{Übung: Vektor}
\begin{frame}{Übung: Vektor-Klasse}
    \lstinputlisting{resources/02_grundlagen/vector_question.py}
    \end{frame}
\begin{frame}{Übung: Vektor-Klasse}
    \lstinputlisting{resources/02_grundlagen/vector.py}
    \end{frame}

\subsection{Super- und Subklassen}
\begin{frame}{Super- und Subklassen}
	Erben / Erweitern: mit \alert{\tt class subclass(superclass):} definieren
	\begin{itemize}
		\item neue Variablen und Methoden hinzufügen, auch alte überschreiben
		\item Superklasse mit \alert{\tt super()} aufrufen
    \end{itemize}
	\lstinputlisting{resources/02_grundlagen/inheritance.py}
\end{frame}
\subsubsection{Übung: Planet}
\begin{frame}{Übung: Planet-Klasse}
    \lstinputlisting{resources/02_grundlagen/planet_question.py}
\end{frame}
\begin{frame}{Übung: Planet-Klasse}
    \lstinputlisting{resources/02_grundlagen/planet.py}
\end{frame}
\begin{frame}{Übung: Planet-Klasse (Fortsetzung)}
    \lstinputlisting{resources/02_grundlagen/planet_2.py}
\end{frame}

\subsection{Spezielle Methoden}
\begin{frame}{Spezielle Methoden}
	von Python intern verwendet

	\begin{description}
        \item<1->[\tt\_\_init\_\_] Bei Instanziierung aufgerufen
		\item<2->[\tt\_\_del\_\_] Bei Löschung aufgerufen (selten)
        \item<3->[\tt\_\_str\_\_] Für Ausgabe als String
        \item<4->[\tt\_\_add\_\_] Funktion für \alert{\tt +}-Operator
        \item<5->[\tt\_\_iadd\_\_] Funktion für \alert{\tt +=}-Operator (muss self zurückgeben)
	\end{description}
\end{frame}
\begin{frame}{Beispiel: Mein Vektor}
    \lstinputlisting{resources/02_grundlagen/Vector.py}
\end{frame}


\end{document}
