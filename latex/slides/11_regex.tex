\documentclass[ignorenonframetext,]{beamer}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{:}
\setbeamercolor{caption name}{fg=normal text.fg}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\usepackage{lmodern}
\ifxetex
  \usepackage{fontspec,xltxtra,xunicode}
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\else
  \ifluatex
    \usepackage{fontspec}
    \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
    \newcommand{\euro}{€}
  \else
    \usepackage[T1]{fontenc}
    \usepackage[utf8]{inputenc}
      \fi
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}

% Comment these out if you don't want a slide with just the
% part/section/subsection/subsubsection title:
\AtBeginPart{
  \let\insertpartnumber\relax
  \let\partname\relax
  \frame{\partpage}
}
\AtBeginSection{
  \let\insertsectionnumber\relax
  \let\sectionname\relax
  \frame{\sectionpage}
}
\AtBeginSubsection{
  \let\insertsubsectionnumber\relax
  \let\subsectionname\relax
  \frame{\subsectionpage}
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

\title{re - Regular Expressions}
\date{}

\begin{document}
\frame{\titlepage}

\section{Grundlage}\label{grundlage}

\begin{frame}

Das \texttt{re} Modul der python standard library ist die Python
Implementierung von regulären Ausdrücken.

Reguläre Ausdrücke werden verwendet um die Struktur von Text/Sprachen zu
beschreiben.

\end{frame}

\begin{frame}

Ein erstellter regulärer Ausdruck kann verwendet werden um:

\begin{itemize}
\tightlist
\item
  die Struktur eines Textes zu überprüfen
\item
  bestimmte Teile eines Textes zu extrahieren
\end{itemize}

\end{frame}

\begin{frame}

Die Anwendung eines regulären Ausdruckes nennt man Matching.

Matcht der reguläre Ausdruck einem String, bedeutet dies, dass der
String die Struktur hat die der reguläre Ausdruck beschreibt.

Reguläre ausdrücke werden oft auch ``regex'' genannt (kurz für regular
Expression).

\end{frame}

\section{Matching Regeln}\label{matching-regeln}

\begin{frame}

Jeder Buchstabe und jede Zahl matcht immer \textbf{einmal} sich selbst.

d.h.

Der String \texttt{"a"} matcht der regex \texttt{"a"}.\\
Der String \texttt{"abc"} matcht der regex \texttt{"abc"}, nicht aber
regex \texttt{"a"}.\\
\texttt{"4"} matcht \texttt{"4"}, nicht aber \texttt{"5"}, \texttt{"a"}
oder \texttt{"41"} usw.

\end{frame}

\begin{frame}{Sonderzeichen}

\texttt{.} (Punkt) matcht \textbf{einem} beliebingen Schriftzeichen,
außer \texttt{\textbackslash{}n} (newline)

Für die regex \texttt{"."} gilt

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"b"} matcht
\item
  \texttt{"4"} matcht
\item
  \texttt{"ab"} matcht nicht, denn \texttt{"."} ist nur ein Zeichen und
  \texttt{"ab"} sind zwei.
\end{itemize}

\end{frame}

\begin{frame}

\texttt{{[}{]}} matcht jedem der in den Klammern stehenden Zeichen,
jedoch nur \textbf{einmal} (wie bei \texttt{.}).

Für die regex \texttt{"{[}abg{]}"} gilt also

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"b"} matcht
\item
  \texttt{"g"} matcht
\item
  \texttt{"ab"} matcht nicht (zwei zeichen matchen nicht einem)
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\textbackslash{}} zum escaped ein Sonderzeichen.

Alle hier aufgeführten Sonderzeichen können nicht in einem Pattern
vorkommen, als das, was sie eigentlich bedeuten, dafür müssen sie extra
markiert werden.

\begin{itemize}
\tightlist
\item
  \texttt{"\textbackslash{}\textbackslash{}"} als Pattern matcht auf den
  String \texttt{"\textbackslash{}"}
\item
  \texttt{"\textbackslash{}."} als Pattern matcht auf den String
  \texttt{"."}
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\^{}} Matcht dem Anfang eines Stings\\
Es matcht alles, was bis zum ersten auftreten des Patterns existert

Für die regex \texttt{"\^{}a"} ergibt sich also

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"ba"} matcht
\item
  \texttt{"aba"} matcht nicht, da nach ``a'' noch weitere Zeichen folgen
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\$} Matcht dem Ende eines Strings (oder das Zeilenende)

Für die regex \texttt{"a\$"} folgt daraus

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"ab"} matcht
\item
  \texttt{"ba"} matcht nicht, da der Anfang nciht stimmt
\item
  \texttt{"aba"} matcht
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\textbar{}} ist ein ODER entweder der Character davor oder der
danach.

Für die regex \texttt{"a\textbar{}b"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"b"} matcht
\item
  \texttt{"ab"} matcht nicht, da \texttt{"a\textbar{}b"} mit {[}ab{]}
  gleichzusetzen ist
\end{itemize}

\end{frame}

\begin{frame}

Regexes bauen sich dann aus kleineren regexes auf.\\
So kann man auch sagen, wie häufig ein Zeichen auftreten soll.

\end{frame}

\begin{frame}

\texttt{*} Die vorangestellte Charakter muss 0 - n Mal vorkommen

Für die regex \texttt{"a*"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{""} matcht
\item
  \texttt{"a"} matcht
\item
  \texttt{"aa"} matcht
\item
  \texttt{"aaaab"} matcht nicht, da ein anderes Zeichen als ``a''
  vorkommt
\end{itemize}

\end{frame}

\begin{frame}

\texttt{+} Der vorangestellte Charakter muss 1 - n Mal vorkommen

Für die regex \texttt{"a+"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{""} matcht nicht, da es kein mal vorkommt
\item
  \texttt{"a"} matcht
\item
  \texttt{"aa"} matcht
\item
  \texttt{"ab"} matcht nicht, da ein anderes Zeichen als ``a'' vorkommt
\end{itemize}

\end{frame}

\begin{frame}

\texttt{?} Der vorangestellte Charakter muss 0 - 1 Mal vorkommen

Für die regex \texttt{"a?"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{""} matcht
\item
  \texttt{"a"} matcht
\item
  \texttt{"aa"} matcht nicht, da das Zeichen öfter, als nur ein mal
  vorkommt
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\{m\}} Der vorangestellte Charakter muss genau m Mal vorkommen

Für die regex \texttt{"y\{3\}"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{yyy} matcht
\item
  \texttt{"y"} matcht nicht, da es zu wenige Zeichen sind
\item
  \texttt{"yyyy"} matcht nicht, da es mehr Zeichen sind
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\{m,n\}} Der vorangestellte Charakter muss m - n Mal vorkommen

Für die regex \texttt{"y\{2,5\}"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{yyy} matcht
\item
  \texttt{"y"} matcht nicht, da es zu wenige Zeichen sind
\item
  \texttt{"yyyy"} matcht
\item
  \texttt{"yyyyyy"} matcht nicht, da es zu viele Zeichen sind
\end{itemize}

\end{frame}

\begin{frame}

Des weiteren gibt es noch spezielle Sequenzen, wie z. B.\\
\texttt{\textbackslash{}d} für Unicode Ziffern, äquivalent für
\texttt{{[}0-9{]}}\\
\texttt{\textbackslash{}D} ist das Gegenteil, alles was keine Unicode
Ziffern sind\\
\texttt{\textbackslash{}s} für alle Whitespace Charaktere, das
entspricht
\texttt{{[}\ \textbackslash{}\textbackslash{}t\textbackslash{}\textbackslash{}n\textbackslash{}\textbackslash{}r\textbackslash{}\textbackslash{}f\textbackslash{}\textbackslash{}v{]}}\\
\texttt{\textbackslash{}S} entspricht wieder dem Gegenteil\\
\texttt{\textbackslash{}w} für alle Unicode Zeichen {[}a-zA-Z0-9\_{]}\\
\texttt{\textbackslash{}W} für alle Nicht-Unicode Zeichen

\end{frame}

\section{Methoden}\label{methoden}

\begin{frame}[fragile]

\begin{verbatim}
compile(pattern, flags=0)
\end{verbatim}

Wandelt einen String in ein regular expression Objekt um

\begin{verbatim}
search(pattern, string, flags=0)
\end{verbatim}

Sucht in \texttt{string} nach dem Pattern \texttt{pattern}

\begin{verbatim}
match(pattern, string, flags=0)
\end{verbatim}

Sucht am Begin des Strings nach dem Pattern

\begin{verbatim}
fullmatch(pattern, string, flags=0)
\end{verbatim}

Der komplette String und das Pattern müssen übereinstimmen.

\end{frame}

\begin{frame}[fragile]

\begin{verbatim}
findall(pattern, string, flags=0)
\end{verbatim}

Gibt eine Liste von Strings mit allen passenden Übereinstimmungen zurück

\begin{verbatim}
finditer(pattern, string, flags=0)
\end{verbatim}

Gibt einen Iterator, welcher \texttt{match} Objekte beinhaltet zurück

Die restlichen Funktionen können in den
\href{https://docs.python.org/3/library/re.html}{Docs} gefunden werden.

\end{frame}

\section{regular expression Objekt}\label{regular-expression-objekt}

\begin{frame}

Ein solches Objekt hat im Großen und Ganzen die selben Methoden, jedoch
ohne zusaätzliches Pattern, da das Objekt an sich bereits ein Pattern
enthält.

\end{frame}

\section{Match Objekt}\label{match-objekt}

\begin{frame}[fragile]

\begin{verbatim}
start([group])
\end{verbatim}

Gibt die Startposition des Patterns im String zurück

\begin{verbatim}
start([group])
\end{verbatim}

Gibt die Endposition des Patterns im String zurück

\begin{verbatim}
span([group])
\end{verbatim}

Gibt ein Tuple zurück \texttt{(m.start({[}group{]}),m.end({[}group{]}))}

\end{frame}

\end{document}
