\documentclass[ignorenonframetext,]{beamer}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{:}
\setbeamercolor{caption name}{fg=normal text.fg}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\usepackage{lmodern}
\ifxetex
  \usepackage{fontspec,xltxtra,xunicode}
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\else
  \ifluatex
    \usepackage{fontspec}
    \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
    \newcommand{\euro}{€}
  \else
    \usepackage[T1]{fontenc}
    \usepackage[utf8]{inputenc}
      \fi
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
\newcommand{\ImportTok}[1]{{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
\newcommand{\BuiltInTok}[1]{{#1}}
\newcommand{\ExtensionTok}[1]{{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}

% Comment these out if you don't want a slide with just the
% part/section/subsection/subsubsection title:
\AtBeginPart{
  \let\insertpartnumber\relax
  \let\partname\relax
  \frame{\partpage}
}
\AtBeginSection{
  \let\insertsectionnumber\relax
  \let\sectionname\relax
  \frame{\sectionpage}
}
\AtBeginSubsection{
  \let\insertsubsectionnumber\relax
  \let\subsectionname\relax
  \frame{\subsectionpage}
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

\title{re - Regular Expressions}
\date{}

\begin{document}
\frame{\titlepage}

\section{Grundlage}\label{grundlage}

\begin{frame}

Das \texttt{re} Modul der python standard library ist die Python
Implementierung von regulären Ausdrücken.

Reguläre Ausdrücke werden verwendet um die Struktur von Text/Sprachen zu
beschreiben.

\end{frame}

\begin{frame}

Ein erstellter regulärer Ausdruck kann verwendet werden um:

\begin{itemize}
\tightlist
\item
  die Struktur eines Textes zu überprüfen
\item
  bestimmte Teile eines Textes zu extrahieren
\end{itemize}

\end{frame}

\begin{frame}

Die Anwendung eines regulären Ausdruckes nennt man Matching.

Matcht der reguläre Ausdruck einem String, bedeutet dies, dass der
String die Struktur hat die der reguläre Ausdruck beschreibt.

Reguläre ausdrücke werden oft auch ``regex'' genannt (kurz für regular
Expression).

\end{frame}

\section{Matching Regeln}\label{matching-regeln}

\begin{frame}

Jeder Buchstabe und jede Zahl matcht immer \textbf{einmal} sich selbst.

d.h.

Der String \texttt{"a"} matcht der regex \texttt{"a"}.\\
Der String \texttt{"abc"} matcht der regex \texttt{"abc"}, nicht aber
regex \texttt{"a"}.\\
\texttt{"4"} matcht \texttt{"4"}, nicht aber \texttt{"5"}, \texttt{"a"}
oder \texttt{"41"} usw.

\end{frame}

\begin{frame}{Sonderzeichen}

\texttt{.} (Punkt) matcht \textbf{einem} beliebingen Schriftzeichen,
außer \texttt{\textbackslash{}n} (newline)

Für die regex \texttt{"."} gilt

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"b"} matcht
\item
  \texttt{"4"} matcht
\item
  \texttt{"ab"} matcht nicht, denn \texttt{"."} ist nur ein Zeichen und
  \texttt{"ab"} sind zwei.
\end{itemize}

\end{frame}

\begin{frame}

\texttt{{[}{]}} matcht jedem der in den Klammern stehenden Zeichen,
jedoch nur \textbf{einmal} (wie bei \texttt{.}).

Für die regex \texttt{"{[}abg{]}"} gilt also

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"b"} matcht
\item
  \texttt{"g"} matcht
\item
  \texttt{"ab"} matcht nicht (zwei zeichen matchen nicht einem)
\end{itemize}

\end{frame}

\begin{frame}

\texttt{()} erstellt eine Gruppe. Alles was in den Klammern steht, muss
genauso vor kommen

Für die regex \texttt{"(abc)"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht nicht
\item
  \texttt{"ab"} matcht nicht
\item
  \texttt{\textquotesingle{}abc\textquotesingle{}} matcht
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\textbackslash{}} zum escaped ein Sonderzeichen.

Alle hier aufgeführten Sonderzeichen können nicht in einem Pattern
vorkommen, als das, was sie eigentlich bedeuten, dafür müssen sie extra
markiert werden.

\begin{itemize}
\tightlist
\item
  \texttt{"\textbackslash{}\textbackslash{}"} als Pattern matcht auf den
  String \texttt{"\textbackslash{}"}
\item
  \texttt{"\textbackslash{}."} als Pattern matcht auf den String
  \texttt{"."}
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\^{}} Matcht dem Anfang eines Stings\\
Es matcht alles, was bis zum ersten auftreten des Patterns existert

Für die regex \texttt{"\^{}a"} ergibt sich also

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"ba"} matcht nicht, da der falsche Character am Begin steht
\item
  \texttt{"aba"} matcht
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\$} Matcht dem Ende eines Strings (oder das Zeilenende)

Für die regex \texttt{"a\$"} folgt daraus

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"ba"} matcht
\item
  \texttt{"bab"} matcht nicht, da der falsche Character am Ende steht
\item
  \texttt{"aba"} matcht
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\textbar{}} ist ein ODER entweder die regex davor oder der
danach.

Für die regex \texttt{"a\textbar{}b"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{"a"} matcht
\item
  \texttt{"b"} matcht
\item
  \texttt{"ab"} matcht nicht, da \texttt{"a\textbar{}b"} mit {[}ab{]}
  gleichzusetzen ist
\end{itemize}

\end{frame}

\begin{frame}

Regexes bauen sich dann aus kleineren regexes auf.\\
So kann man auch sagen, wie häufig ein Zeichen auftreten soll.

\end{frame}

\begin{frame}

\texttt{*} Die vorangestellte regex muss 0 - n Mal vorkommen

Für die regex \texttt{"a*"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{""} matcht
\item
  \texttt{"a"} matcht
\item
  \texttt{"aa"} matcht
\item
  \texttt{"aaaab"} matcht nicht, da ein anderes Zeichen als ``a''
  vorkommt
\end{itemize}

\end{frame}

\begin{frame}

\texttt{+} Die vorangestellte regex muss 1 - n Mal vorkommen

Für die regex \texttt{"a+"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{""} matcht nicht, da es kein mal vorkommt
\item
  \texttt{"a"} matcht
\item
  \texttt{"aa"} matcht
\item
  \texttt{"ab"} matcht nicht, da ein anderes Zeichen als ``a'' vorkommt
\end{itemize}

\end{frame}

\begin{frame}

\texttt{?} Die vorangestellte regex muss 0 - 1 Mal vorkommen

Für die regex \texttt{"a?"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{""} matcht
\item
  \texttt{"a"} matcht
\item
  \texttt{"aa"} matcht nicht, da das Zeichen öfter, als nur ein mal
  vorkommt
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\{m\}} Die vorangestellte regex muss genau m Mal vorkommen

Für die regex \texttt{"y\{3\}"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{"yyy"} matcht
\item
  \texttt{"y"} matcht nicht, da es zu wenige Zeichen sind
\item
  \texttt{"yyyy"} matcht nicht, da es mehr Zeichen sind
\end{itemize}

\end{frame}

\begin{frame}

\texttt{\{m,n\}} Die vorangestellte regex muss m - n Mal vorkommen

Für die regex \texttt{"y\{2,5\}"} gilt

\begin{itemize}
\tightlist
\item
  \texttt{"yyy"} matcht
\item
  \texttt{"y"} matcht nicht, da es zu wenige Zeichen sind
\item
  \texttt{"yyyy"} matcht
\item
  \texttt{"yyyyyy"} matcht nicht, da es zu viele Zeichen sind
\end{itemize}

\end{frame}

\begin{frame}

Des weiteren gibt es noch spezielle Sequenzen, wie z. B.\\
\texttt{\textbackslash{}d} für Unicode Ziffern, äquivalent für
\texttt{{[}0-9{]}}\\
\texttt{\textbackslash{}D} ist das Gegenteil, alles was keine Unicode
Ziffern sind\\
\texttt{\textbackslash{}s} für alle Whitespace Charaktere, das
entspricht
\texttt{"{[}\ \textbackslash{}\textbackslash{}t\textbackslash{}\textbackslash{}n\textbackslash{}\textbackslash{}r\textbackslash{}\textbackslash{}f\textbackslash{}\textbackslash{}v{]}"}\\
\texttt{\textbackslash{}S} entspricht wieder dem Gegenteil\\
\texttt{\textbackslash{}w} für alle Unicode Zeichen
\texttt{"{[}a-zA-Z0-9\_{]}"}\\
\texttt{\textbackslash{}W} für alle Nicht-Unicode Zeichen\\
\texttt{{[}\^{}...{]}} entspricht allem, was nicht in den Klammern steht

\end{frame}

\section{Methoden}\label{methoden}

\begin{frame}[fragile]

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{compile}\NormalTok{(pattern, flags}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Wandelt einen String in ein regular expression Objekt um

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{search(pattern, string, flags}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Sucht in \texttt{string} nach dem Pattern \texttt{pattern}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{match(pattern, string, flags}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Sucht am Begin des Strings nach dem Pattern

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fullmatch(pattern, string, flags}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Der komplette String und das Pattern müssen übereinstimmen.

\end{frame}

\begin{frame}[fragile]

\begin{verbatim}
findall(pattern, string, flags=0)
\end{verbatim}

Gibt eine Liste von Strings mit allen passenden Übereinstimmungen zurück

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{finditer(pattern, string, flags}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Gibt einen Iterator, welcher \texttt{match} Objekte beinhaltet zurück

Die restlichen Funktionen können in den
\href{https://docs.python.org/3/library/re.html}{Docs} gefunden werden.

\end{frame}

\section{regular expression Objekt}\label{regular-expression-objekt}

\begin{frame}

Ein solches Objekt hat im Großen und Ganzen die selben Methoden, jedoch
ohne zusaätzliches Pattern, da das Objekt an sich bereits ein Pattern
enthält.

\end{frame}

\section{Match Objekt}\label{match-objekt}

\begin{frame}[fragile]

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{start([group])}
\end{Highlighting}
\end{Shaded}

Gibt die Startposition des Patterns im String zurück

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{start([group])}
\end{Highlighting}
\end{Shaded}

Gibt die Endposition des Patterns im String zurück

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{span([group])}
\end{Highlighting}
\end{Shaded}

Gibt ein Tuple zurück \texttt{(m.start({[}group{]}),m.end({[}group{]}))}

\end{frame}

\end{document}
